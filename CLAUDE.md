# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Commands

```bash
npm start                # Dev server with nodemon + local env (auto-rebuilds on change)
npm run build            # Full build: compile .gql schemas → compile TS → resolve aliases
npm run compile:gql      # Regenerate src/graphql/generated/resolved.ts from .gql schemas
npm run compile:ts       # tsc + tsc-alias (resolves path aliases in output)
npm run lint             # ESLint (zero warnings allowed: --max-warnings 0)
npm run prettier         # Check formatting
npm run prettier:fix     # Auto-fix formatting
npm run test             # Runs compile:gql first, then Jest with test.env (serial: --runInBand)
npm run test:ci          # Same as test but with --coverage
npm run db:create:local  # Populates local MongoDB with seed data (color, petType)
```

To run a single test file:
```bash
npm run env:test -- npx jest --testPathPattern=src/graphql/resolvers/tests/Mutations.test.ts --runInBand
```

GraphQL Playground (local dev): `http://localhost:4000/graphql`

## Environment

Two env files in `env/`. Loaded via `env-cmd`: `local.env` for `npm start`, `test.env` for `npm test`. Key variables shared by both:

| Variable | Purpose |
|---|---|
| `PORT` | Server port |
| `CONNECTION_URL` | MongoDB connection string |
| `JWT_SECRET` | Secret for signing JWTs |
| `CRYPT_SECRET` | Secret for crypto-js password encryption |
| `CRYPT_METH` | Encryption algorithm (e.g. `AES`) |
| `CRYPT_SALT` | bcrypt salt rounds for password hashing |

ESLint ignores `src/functions/dbOps.ts` and the entire `src/graphql/generated` and `src/graphql/schemas` directories.

## Path Aliases

Defined in `tsconfig.json` and mirrored in `jest.config.js` `moduleNameMapper`. Output aliases are resolved at build time by `tsc-alias`.

| Alias | Maps to |
|---|---|
| `@constants/*` | `src/constants/*` |
| `@functions/*` | `src/functions/*` |
| `@models/*` | `src/db/models/*` |
| `@resolvers/*` | `src/graphql/resolvers/*` |
| `@schemas/*` | `src/graphql/schemas/*` |
| `@interfaces/*` | `src/interfaces/*` |

## Architecture

**Stack:** Express 5 + Apollo Server 5 + GraphQL + Mongoose (MongoDB) + TypeScript + Jest. Compiled to `dist/` via `tsc` + `tsc-alias`.

**Startup (`src/index.ts`):** Creates the Express app, mounts Apollo Server at `/graphql` with a `context` middleware. That middleware extracts the `Authorization: Bearer <token>` header, verifies it with `jwt.verify`, looks up the user in MongoDB by `_id` + matching token, and injects `{ loggedUser, token }` into every resolver's context. Unauthenticated requests get an empty context `{}`.

**Apollo Server setup (`src/server/server.ts`):** Reads the four `.gql` schema files via `readFileSync`, assembles `typeDefs`, and wires in the three resolver groups: `Query`, `Mutation`, and the relationship resolvers spread directly into the config.

**GraphQL schema split across four `.gql` files:**
- `Entities.gql` — core types (`User`, `Pet`, `Event`, `AuxiliaryData`, `AmountData`)
- `Payloads.gql` — all `input` types (mutation arguments)
- `Responses.gql` — response-only types (`LoginUserResponse`, `UserCreateResponse`)
- `Operations.gql` — the `Query` and `Mutation` root type declarations

**`src/graphql/generated/resolved.ts`** is auto-generated by `@graphql-codegen` from the `.gql` schemas. Never edit manually. Regenerate with `npm run compile:gql`.

**Resolver structure (`src/graphql/resolvers/`):**
- `Queries.ts` — read operations. Most require `context.loggedUser`; `getPetTypes` and `getColors` are public (no auth needed).
- `Mutations.ts` — write operations. `loginUser` and `createUser` don't need context; everything else does. Errors are thrown as `GraphQLError` with HTTP status codes from `HTTP_CODES`.
- `Relationships.ts` — resolves nested entity fields (e.g. `Pet.petType` → looks up PetType by ObjectId, `User.pets` → finds all Pets for that user). These are spread into the Apollo resolvers config as `{ User: {...}, Pet: {...}, Event: {...} }`.

**Auth & password flow:** Passwords arrive from the front-end pre-encrypted with crypto-js. The back-end decrypts them (`decryptPass`) before hashing with bcrypt and storing. On login, same decrypt → bcrypt compare. JWTs are signed with `jwt.sign({ _id })` and appended to the user's `tokens` array in the DB. Logout removes the token from that array.

**Database models (`src/db/models/`):**
- `user.model.ts` — has custom statics (`findByCredentials`), instance methods (`generateAuthToken`, `toJSON` that strips sensitive fields), a `pre('save')` hook for bcrypt hashing, and a virtual `pets` field.
- `pet.model.ts` — stores `petType`, `hairColors`, `eyeColors` as ObjectId refs; `events` as an array of Event ObjectIds maintained manually by the mutations.
- `event.model.ts` — stores `associatedPets` as ObjectId refs.
- `color.model.ts` / `petType.model.ts` — simple `{ name }` lookup tables, typed with the shared `EntityDocument` interface.

**Constants (`src/constants/errors.ts`):** All error messages and HTTP status codes live here as enums (`ERROR_MSGS`, `HTTP_CODES`, `SERVER_MSGS`). Resolvers always throw `GraphQLError` using these.

**Utility functions (`src/functions/`):**
- `encrypt.ts` — `encryptPass` / `decryptPass` wrappers around crypto-js, method chosen by `CRYPT_METH` env var.
- `parsers.ts` — `parseErrorMessage` (translates Mongoose errors into user-facing strings using `SERVER_MSGS` patterns), `findByIds` (generic model lookup by single or array of ObjectIds), `parseUniqueArray`, `generateMongooseDate`, and the `parseErrorMsg` factory object for dynamic error strings.
- `dbOps.ts` — `populateTable`, `clearTable`, `clearAllTables`. Used by seed scripts and test setup. Imports seed data from `mocks/dbOps.mocks.ts`.

**Interfaces (`src/interfaces/`):** One file per domain. `shared.ts` has the generic types used everywhere: `EntityObject`, `EntityDocument`, `TypedQuery`, `TypedMutation`, `TypedRelationship` (typed signatures for resolver functions). Domain files (`user.ts`, `pet.ts`, `event.ts`) define Document interfaces, payload interfaces, and response interfaces.

## Testing Patterns

Tests are **integration tests against a real MongoDB instance** (configured via `test.env`'s `CONNECTION_URL`). They are NOT mocked at the DB level.

- `scripts/init-tests.ts` — Jest `globalSetup`. Starts the Apollo server and binds it to Express so the Mongoose connection is live before any test runs.
- `scripts/close-tests.ts` — Jest `globalTeardown`. Drops the entire test database and disconnects Mongoose.
- Tests call resolvers **directly as functions** (e.g. `Mutations.createUser(null, { payload }, context)`), not via HTTP. The first argument (`_` / `hasNoUsage`) is always `null`.
- Each `describe` block manages its own data lifecycle: `beforeAll` populates tables / creates entities; `afterAll` (or `afterEach`) calls `clearTable` / `clearAllTables`.
- Seed data comes from `src/functions/mocks/dbOps.mocks.ts` (`.ts` file, not `.json`). Resolver-specific mock payloads are in `src/graphql/resolvers/mocks/*.mocks.json`.
- Tests are structured with nested `[HAPPY PATH]` and `[SAD PATH]` describe blocks. Sad-path tests use `try/catch` and assert on `error.message`.
- Tests run serially (`--runInBand`) because they share the same MongoDB instance.
